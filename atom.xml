<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>长长的路慢慢地走</title>
  
  <subtitle>不将就，不妥协，不停留。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://crazyxxn.github.io/"/>
  <updated>2019-05-30T03:08:16.183Z</updated>
  <id>http://crazyxxn.github.io/</id>
  
  <author>
    <name>no one</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://crazyxxn.github.io/2019/05/13/test/"/>
    <id>http://crazyxxn.github.io/2019/05/13/test/</id>
    <published>2019-05-13T12:58:38.000Z</published>
    <updated>2019-05-30T03:08:16.183Z</updated>
    
    <content type="html"><![CDATA[<p>stay hungry,stay foolish.</p><pre><code> public static int [] twoSum(int[] nums, int target){    int [] ints;    ints = new int[2];    for(int i = 0;i &lt; nums.length -1;i ++)        for (int j = i + 1; j &lt; nums.length; j++) {            int tmp = nums[i] + nums[j];            if (target == tmp) {                ints[0] = i;                ints[1] = j;                System.out.println(i + &quot;+&quot; + j);                break;            }    }         return  ints;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;stay hungry,stay foolish.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public static int [] twoSum(int[] nums, int target){
    int [] ints;
    ints = new int[2];
  
      
    
    </summary>
    
      <category term="Testing" scheme="http://crazyxxn.github.io/categories/Testing/"/>
    
    
  </entry>
  
  <entry>
    <title>test_my_site</title>
    <link href="http://crazyxxn.github.io/2019/05/09/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0HadoopRPC/"/>
    <id>http://crazyxxn.github.io/2019/05/09/测试文章HadoopRPC/</id>
    <published>2019-05-09T14:34:37.000Z</published>
    <updated>2019-05-30T02:15:54.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、RPC远程过程调用"><a href="#1、RPC远程过程调用" class="headerlink" title="1、RPC远程过程调用"></a>1、RPC远程过程调用</h1><h2 id="1-1、RPC概念"><a href="#1-1、RPC概念" class="headerlink" title="1.1、RPC概念"></a>1.1、RPC概念</h2><p> RPC(Remote Procedure Call)—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。  </p><pre><code>第七层：应用层。定义了用于在网络中进行通信和传输数据的接口；  第六层：表示层。定义不同的系统中数据的传输格式，编码和解码规范等；  第五层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断；  第四层：传输层。管理着网络中的端到端的数据传输；  第三层：网络层。定义网络设备间如何传输数据；  第二层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输；  第一层：物理层。这一层主要就是传输这些二进制数据。  </code></pre><p>HTTP是应用层协议；TCP是传输层协议。  </p><p>RPC采用客户机/服务器（C/S）模式：请求程序就是一个客户机，而服务提供程序就是一个服务器。  </p><h2 id="1-2、为什么要有RPC"><a href="#1-2、为什么要有RPC" class="headerlink" title="1.2、为什么要有RPC"></a>1.2、为什么要有RPC</h2><blockquote><p>RPC框架的职责是：让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务，并且屏蔽编程语言的差异性。<br>  RPC的主要功能目标是让构建分布式计算（应用）更容易，在提供墙打的远程调用能力时不损失本地调用的语义简洁性。  </p></blockquote><h2 id="1-3、Java中流行的RPC框架"><a href="#1-3、Java中流行的RPC框架" class="headerlink" title="1.3、Java中流行的RPC框架"></a>1.3、Java中流行的RPC框架</h2><h3 id="1、RMI（远程方法调用）"><a href="#1、RMI（远程方法调用）" class="headerlink" title="1、RMI（远程方法调用）"></a>1、RMI（远程方法调用）</h3><p>JAVA自带的远程方法调用工具，不过有一定的局限性，毕竟是java语言最开始时设计的，后来很多框架的原理都基于RMI  </p><h3 id="2、Hessian（基于HTTP的远程方法调用）"><a href="#2、Hessian（基于HTTP的远程方法调用）" class="headerlink" title="2、Hessian（基于HTTP的远程方法调用）"></a>2、Hessian（基于HTTP的远程方法调用）</h3><p>  基于HTTP协议传输，在性能方面还不够完美，负载均衡和失效转移依赖于应用的负载均衡器，Hessian的使用则与RMI类似，区别在于淡化了Registry的角色，通过显示的地址调用，利用HessianProxyFactory根据配置的地址create一个代理对象，另外还要引入Hessian的Jar包。</p><h3 id="3、Dubbo（阿里开源的基于TCP的RPC框架）"><a href="#3、Dubbo（阿里开源的基于TCP的RPC框架）" class="headerlink" title="3、Dubbo（阿里开源的基于TCP的RPC框架）"></a>3、Dubbo（阿里开源的基于TCP的RPC框架）</h3><pre><code>基于 Netty 的高性能 RPC 框架，是阿里巴巴开源的  </code></pre><p> 阿里的 dubbo 现在已经贡献给 Apache 了，官网是：<a href="http://dubbo.apache.org/" target="_blank" rel="noopener">http://dubbo.apache.org/</a><br> Duboo 的中文官网：<br>   <a href="https://dubbo.gitbooks.io/dubbo-user-book/content/preface/background.html" target="_blank" rel="noopener">https://dubbo.gitbooks.io/dubbo-user-book/content/preface/background.html</a></p><p><img id="bigImg" style="width: 690px; height: 430px;" src="http://wx3.sinaimg.cn/mw690/005QlB3Zly1g2zwae1dg0j30ln0di0tz.jpg" is_load="1"></p><h1 id="2、Hadoop-RPC"><a href="#2、Hadoop-RPC" class="headerlink" title="2、Hadoop RPC"></a>2、Hadoop RPC</h1><h2 id="2-1、Hadoop-RPC-概述"><a href="#2-1、Hadoop-RPC-概述" class="headerlink" title="2.1、Hadoop RPC 概述"></a>2.1、Hadoop RPC 概述</h2><p>&emsp;&emsp;  同其他 RPC 框架一样，Hadoop RPC 分为四个部分：</p><p><strong>1、序列化层</strong>：Client 与 Server 端通信传递的信息采用了 Hadoop 里提供的序列化类或自定义<br>的 Writable 类型；<br><strong>2、函数调用层</strong>：Hadoop RPC 通过动态代理以及 Java 反射实现函数调用；<br><strong>3、网络传输层</strong>：Hadoop RPC 采用了基于 TCP/IP 的 socket 机制；<br><strong>4、服务器端框架层</strong>：RPC Server 利用 Java NIO 以及采用了事件驱动的 I/O 模型，提高 RPC Server 的并发处理能力；  </p><pre><code>Hadoop RPC 在整个 Hadoop 中应用非常广泛，Client、DataNode、NameNode 之间的通讯全靠它了。例如：我们平时操作 HDFS 的时候，使用的是 FileSystem 类，它的内部有个 DFSClient对象，这个对象负责与 NameNode 打交道。在运行时，DFSClient 在本地创建一个 NameNode的代理，然后就操作这个代理，这个代理就会通过网络，远程调用到 NameNode 的方法，也能返回值。 </code></pre><h2 id="2-2、Hadoop-RPC-涉及的技术"><a href="#2-2、Hadoop-RPC-涉及的技术" class="headerlink" title="2.2、Hadoop RPC 涉及的技术"></a>2.2、Hadoop RPC 涉及的技术</h2><p> <strong>1、代理</strong>：动态代理可以提供另一个对象的访问，同时隐藏实际对象的具体事实，代理对象对客户隐藏了实际对象。目前Java开发包中提供了对动态代理的支持，但现在只支持对接口的实现。<br><strong>2、反射</strong>—-动态加载类<br><strong>3、序列化</strong>—-在网络中传输数据必然会涉及到对象的序列化和反序列化<br><strong>4、非阻塞的异步IO(NIO)</strong>  </p><h2 id="2-3、Hadoop-RPC对外提供的接口"><a href="#2-3、Hadoop-RPC对外提供的接口" class="headerlink" title="2.3、Hadoop RPC对外提供的接口"></a>2.3、Hadoop RPC对外提供的接口</h2><p>Hadoop RPC 对外主要提供了两种接口（见类org.apache.hadoop.ipc.RPC），分别是：<br><strong>1、public static<t> ProtocolProxy<t> getProxy/waitForProxy(…)</t></t></strong><br>构造一个客户端代理对象（该对象实现了某个协议），用于向服务器发送RPC请求。<br><strong>2、public static Sever RPC.Builder(Configuration).build()</strong><br>为某个协议（实际上是java接口）实例构造一个服务器对象，用于处理客户端发送的请求。  </p><h2 id="2-4、使用Hadoop-RPC构建应用的步骤"><a href="#2-4、使用Hadoop-RPC构建应用的步骤" class="headerlink" title="2.4、使用Hadoop RPC构建应用的步骤"></a>2.4、使用Hadoop RPC构建应用的步骤</h2><p><strong>1、定义RPC协议</strong><br>RPC协议是客户端和服务器端之间的通信接口，它定义了服务器端对外提供的服务接口。<br><strong>2、实现RPC协议</strong><br>Hadoop RPC 协议通常是一个java接口，用户需要实现该接口。<br><strong>3、构造和启动RPC SERVER</strong><br>直接使用静态类Builder构造一个RPC Sever,并调用函数start（）启动该Server。<br><strong>4、构造RPC Client并发送请求</strong><br>使用静态方法getProxy构造客户端代理对象，直接通过代理对象调用远程端的方法。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、RPC远程过程调用&quot;&gt;&lt;a href=&quot;#1、RPC远程过程调用&quot; class=&quot;headerlink&quot; title=&quot;1、RPC远程过程调用&quot;&gt;&lt;/a&gt;1、RPC远程过程调用&lt;/h1&gt;&lt;h2 id=&quot;1-1、RPC概念&quot;&gt;&lt;a href=&quot;#1-1、RPC概
      
    
    </summary>
    
    
      <category term="Testing" scheme="http://crazyxxn.github.io/tags/Testing/"/>
    
      <category term="Another Tag" scheme="http://crazyxxn.github.io/tags/Another-Tag/"/>
    
  </entry>
  
</feed>
